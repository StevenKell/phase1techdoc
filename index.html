<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>oneAPI Math Kernel Library</title>
    <link rel="stylesheet" href="styles.css">
    <link rel="stylesheet" href="darkmode.css">

    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link
        href="https://fonts.googleapis.com/css2?family=Barlow+Condensed:ital,wght@0,100;0,200;0,300;0,400;0,500;0,600;0,700;0,800;0,900;1,100;1,200;1,300;1,400;1,500;1,600;1,700;1,800;1,900&display=swap"
        rel="stylesheet">
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Emilys+Candy&display=swap" rel="stylesheet">
</head>

<body>
    <script src="https://cdn.freecodecamp.org/testable-projects-fcc/v1/bundle.js"></script>
    <nav id="navbar">
        <header>
            <h1>oneAPI Math Kernel Library</h1>
        </header>
        <ul>
            <li><a class="nav-link" href="#Introduction">Introduction</a></li>
            <li><a class="nav-link" href="#Math_Routines_and_Functions">Math Routines and Functions</a></li>
            <li> <a class="nav-link" href="#Support_Functions">Support Functions</a>
            </li>
            <li> <a class="nav-link" href="#Industry_Examples">Industry Examples</a>
            </li>
            <li> <a class="nav-link" href="#Code_Examples">Code Examples</a>
            </li>

        </ul>
    </nav>
    <main id="main-doc">
        <section id="Introduction" class="main-section">
            <header>
                <h2>Introduction</h2>
            </header>
            <hr>
            <article>
                <h3>What is the Math Kernel Library</h3>
                <p>
                    This page about the oneAPI Math Kernel Library is intended for developers looking to use the C
                    interface to integrate the api into Python applications. The Math Kernel Library provides
                    a number of techniques to optimize computations.

                    From the <a
                        href="https://www.intel.com/content/www/us/en/docs/onemkl/developer-reference-c/2024-2/performance-enhancements.html">official
                        documentation</a> :
                </p>
                <ul>
                    <li>Loop unrolling to minimize loop management costs</li>
                    <li>Blocking of data to improve data reuse opportunities</li>
                    <li>Copying to reduce chances of data eviction from cache</li>
                    <li>Data prefetching to help hide memory latency</li>
                    <li>Multiple simultaneous operations (for example, dot products in dgemm) to eliminate stalls due to
                        arithmetic unit pipelines</li>
                    <li>Use of hardware features such as the SIMD arithmetic units, where appropriate</li>
                </ul>

            </article>
        </section>
        <section id="Math_Routines_and_Functions" class="main-section">
            <header>
                <h2>Math Routines and Functions</h2>
            </header>
            <hr>
            <article>
                <h3>A wide assortment of high speed operations</h3>
                <p>BLAS - Basic Linear Algebra Subprogram functions are
                    grouped into three levels basic on the structures they operate on. </p>
                <ul>
                    <li>level 1 : vector - vector operations </li>
                    <li>level 2 : matrix - vector operations </li>
                    <li>level 3 : matrix - matrix operations </li>
                </ul>


                <p>
                    Sparse BLAS - Used for vectors populated mostly with zeros, these functions are also grouped into
                    three levels.
                </p>
                <p>
                    Sparse QR
                </p>


                <p> LAPACK

                </p>


            </article>
        </section>
        <section id="Support_Functions" class="main-section">


            <header>
                <h2>Support Functions</h2>
            </header>
            <hr>
            <article>
                <h3>Functions that help manage the usage of oneAPI MKL</h3>
                <p>
                    Domains include Version Information,
                    Threading Control, Error Handling, Character Equality Testing, Timing, Memory Management,
                    Single Dynamic Library Control, Conditional Numerical Reproducibility Control.
                    Here is a random selection of functions:
                </p>
                <ul>
                    <li> <code> mkl_get_version</code> - Returns the Intel速 oneAPI Math Kernel Library (oneMKL) version.
                    </li>
                    <li> <code> mkl_set_num_threads</code> - Specifies the number of OpenMP* threads to use.</li>
                    <li> <code>xerbla</code> Function for handling errors
                        used by BLAS, LAPACK, Vector Math, and Vector Statistics functions. Returns an error code. </li>
                </ul>


            </article>
        </section>
        <section id="Industry_Examples" class="main-section">
            <header>
                <h2>Industry Examples</h2>
            </header>
            <hr>
            <article>
                <h3>How the MKL is used to produce value</h3>

                <a href="https://github.com/oneapi-src/oneAPI-samples/tree/master/Libraries/oneMKL/black_scholes">Black-Scholes
                    Sample</a>
                <p>"Black-Scholes shows how to use Random Number Generator (RNG)
                    functionality available in Intel速 oneAPI Math Kernel Library (oneMKL)
                    to calculate the prices of options using the Black-Scholes
                    formula for suitable randomly-generated portfolios."</p>
                <a
                    href="https://github.com/oneapi-src/oneAPI-samples/tree/master/Libraries/oneMKL/monte_carlo_european_opt">Monte
                    Carlo European Options Sample</a>

                <p>"Monte Carlo European Options shows how to use the Intel速 oneAPI Math Kernel Library (oneMKL) random
                    number generation (RNG) functionality to compute European option prices."</p>
                <a href="https://github.com/oneapi-src/oneAPI-samples/tree/master/Libraries/oneMKL/computed_tomography">Computed
                    Tomography Reconstruction Sample</a>
                <p>"Computed Tomography shows how to use the Intel速 oneAPI Math Kernel Library (oneMKL) DFT
                    functionality to simulate computed tomography (CT) imaging."</p>
            </article>
        </section>
        <section id="Code_Examples" class="main-section">
            <header>
                <h2>Code Examples</h2>
            </header>
            <hr>
            <article>
                <h3>Snippets of code</h3>
                <p> This example demonstrates how to use the cblas_dgemm function
                    to perform matrix multiplication. The example, which is coded in C++ was generated by
                    <a href="https://huggingface.co/ibm-granite/granite-8b-code-instruct-4k">IBM's Granite Code 8B</a> .
                    <code>#include &lt;mkl.h&gt;
                        #include &lt;iostream&gt;
                        
                        int main() {
                          int m = 3; // Number of rows in the first matrix
                          int n = 4; // Number of columns in the second matrix
                          int k = 5; // Number of columns in the first matrix and rows in the second matrix
                        
                          double alpha = 1.0; // Scalar factor for the first matrix
                          double beta = 0.0; // Scalar factor for the second matrix
                        
                          double A[m][k] = {{1, 2, 3, 4, 5}, {6, 7, 8, 9, 10}, {11, 12, 13, 14, 15}}; // First matrix
                          double B[k][n] = {{16, 17, 18, 19}, {20, 21, 22, 23}, {24, 25, 26, 27}, {28, 29, 30, 31}, {32, 33, 34, 35}}; // Second matrix
                          double C[m][n] = {{0, 0, 0, 0}, {0, 0, 0, 0}, {0, 0, 0, 0}}; // Output matrix
                        
                          cblas_dgemm(CblasColMajor, CblasNoTrans, CblasTrans, m, n, k, alpha, A, m, B, n, beta, C, m);
                        
                          for (int i = 0; i &lt; m; i++) {
                            for (int j = 0; j &lt; n; j++) {
                              std::cout &lt;&lt; C[i][j] &lt;&lt; " ";
                            }
                            std::cout &lt;&lt; std::endl;
                          }
                        
                          return 0;
                        }</code>
                    This example which was also generated by IBMs Granite Code is wriiten in Python and uses the Numpy
                    library to perform matrix multiplication.
                    <code>
                        import numpy as np
from mkl import get_max_threads

def dgemm(transa, transb, m, n, k, alpha, a, b, beta, c):
    # Call the dgemm function from the MKL library
    c = blas.dgemm(transa, transb, m, n, k, alpha, a, b, beta, c)

    return c

# Example usage of the dgemm function
m = 3
n = 4
k = 5
alpha = 1.0
beta = 0.0

a = np.array([[1, 2, 3, 4, 5], [6, 7, 8, 9, 10], [11, 12, 13, 14, 15]], dtype=np.float64)
b = np.array([[16, 17, 18, 19], [20, 21, 22, 23], [24, 25, 26, 27], [28, 29, 30, 31], [32, 33, 34, 35]], dtype=np.float64)
c = np.zeros((m, n), dtype=np.float64)

c = dgemm('N', 'T', m, n, k, alpha, a, b, beta, c)

print(c)



                    </code>

                </p>
            </section>
            </article>

    </main>
</body>

</html>